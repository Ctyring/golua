---
--- Generated by Luanalysis
--- Created by Lenovo.
--- DateTime: 2022/12/24 16:36
---
-- 元表和元方法
-- 每一个表和用户数据类型有自己的元表，其他类型共享对应类型所属的同一个元表
-- Lua语言在创建新表时不带元表
t = {}
print(getmetatable(t)) -- nil
---- 使用setmetatable函数可以设置表的元表
t1 = {}
setmetatable(t, t1)
--print(getmetatable(t)) -- table: 0x7f8c0c0a0e60
-- 在lua语言中只能为表设置元表，要设置其他类型的值的元表，则必须通过C代码或调试库完成。
local Set = require "set"
local s1 = Set.new{2, 4}
local s2 = Set.new{4, 10, 2}
print(Set.tostring(s1 + s2))
print(Set.tostring(s1 * s2))
print(s1 <= s2)
print(s1 < s2)
print(s1 >= s2)
print(s1 > s2)
print(s1 == s2 * s1)
---- 当一个表中混合了两种不同元表的值时，会按照以下步骤来查找元方法
---- 如果一个值有元表且元表中有对应的元方法，则使用该元方法
---- 如果第二个值有元表且元表中有对应的元方法，则使用该元方法
---- 否则抛出异常
---- 库定义相关的元方法
---- 在Set中定义__tostring元方法之后，就可以使用print调用
--print(s1)
---- getmetatable 和 setmetatable 也用到了元方法
---- 表相关的元方法
---- __index元方法
---- 当访问一个表中不存在的键时，Lua会调用__index元方法
---- __index元方法可以是一个表，也可以是一个函数
---- 如果是一个表，则Lua会在该表中查找对应的键
---- 如果是一个函数，则Lua会调用该函数，传入表和键作为参数
---- 如果不希望使用元方法，可以调用rawget函数
---- __newindex元方法 用于表的更新
---- 作用1 设置表的默认值
---- 作用2 跟踪对表的访问
---- 实现一个空表作为代理
function track(t)
    local proxy = {}
    local mt = {
        __index = function(_, k)
            print("*access to element " .. tostring(k))
            return t[k]
        end,
        __newindex = function(_, k, v)
            print("*update of element " .. tostring(k) .. " to " .. tostring(v))
            t[k] = v
        end
    }
    setmetatable(proxy, mt)
    return proxy
end
t = track({})
t[2] = "hello"
print(t[2])
---- 只读表
function readOnly(t)
    local proxy = {}
    local mt = {
        __index = t,
        __newindex = function(t, k, v)
            error("attempt to update a read-only table", 2)
        end
    }
    setmetatable(proxy, mt)
    return proxy
end
days = readOnly{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
print(days[1])
days[2] = "Noday"