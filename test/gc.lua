---
--- Generated by Luanalysis
--- Created by Lenovo.
--- DateTime: 2023/1/2 15:19
---
-- 弱引用表
-- 告知Lua语言一个引用不应组织对一个对象回收的机制
-- 一个表是否为弱引用表由__mode字段决定
a = {}
mt = {__mode = "k"} -- key是弱引用
setmetatable(a, mt)
key = {}
a[key] = 1
key = {}
a[key] = 2
collectgarbage()
for k, v in pairs(a) do
    print(k, v) -- 2 第一个key已经没有人引用了，所以被回收了
end
-- 记忆函数
local result = {}
setmetatable(result, {__mode = "v"}) -- 让值成为弱引用，这样每次垃圾回收都会删除未使用的结果，这样能防止不断积累导致内存泄漏
function mem_loadstring(s)
    local res = result[s]
    if res == nil then
        res = assert(load(s))
        result[s] = res -- 记忆查询结果，以后就不用再调用load查询
    end
    return res
end
-- 对象属性
-- 对偶表示：我们把对象作为值存储在一个表中，这个表的键是对象的属性，我们让这个表弱引用对象的键，这样就可以在对象被回收时自动删除这个表中的属性

-- 具有默认值的表
-- 方案一：对偶表示
local defaults = {}
setmetatable(defaults, {__mode = "k"})
local mt = {
    __index = function(t)
        return defaults[t]
    end
}
function setDefault(t, d)
    defaults[t] = d
    setmetatable(t, mt)
end
-- 方案二：记忆技术
local metas = {}
setmetatable(metas, {__mode = "k"})
function setDefault(t, d)
    local mt = metas[d]
    if mt == nil then
        mt = {__index = function() return d end}
        metas[d] = mt
    end
    setmetatable(t, mt)
end
-- 两种方案的比较
-- 方案一需要为每个具有默认值的表分配几个字节的内存(defaults表中的一个元素)
-- 方案二需要为每个不同默认值分配若干内存(一个新表、一个新闭包和metas表中的一个元素)
-- 因此，如果应用中有上千个具有少量不同默认值的表，第二种实现更好，反之，如果应用中只有少量共享默认值的表，第一种方案更好

-- 瞬表
-- 在Lua语言中，一个具有弱引用键和强引用值的表是一个瞬表，在瞬表中，即使值间接或直接引用了键，键也会被回收，除非键被外界引用。

-- 析构器
-- 使用元方法__gc实现
o = {x = "hi"}
setmetatable(o, {__gc = function(o) print(o.x) end})
o = nil
collectgarbage() -- hi
-- 必须在创建表的时候提供__gc字段，如果必须后期处理也要添加占位符，否则后期添加的__gc字段无法被识别
-- 复苏
-- 当一个析构器被调用时，它的参数是正在被析构的对象，导致被析构的对象变活跃，这被称为临时复苏
-- 在析构器执行期间，如果把该对象存储到了全局变量中，会导致该对象在析构器返回后仍然可以访问，这被称为永久复苏
-- 因为这种特性的存在，Lua语言会通过两个阶段回收具有析构器的对象。当垃圾回收器首次发现某个对象不可达时，把这个对象复苏并将其放入等待被析构的队列中
-- 一旦析构器开始执行，Lua语言就将该对象标记为已被析构。当下一次垃圾收集器又发现这个对象不可达时，会将这个对象删除。所以如果想确保所有垃圾都被释放
-- 需要调用两次collectgarbage函数
-- 利用__gc的特性我们可以做一些操作
-- 1.在程序运行结束时进行某些操作
local t = {__gc = function ()
    print("finishing Lua program")
end}
setmetatable(t, t)
_G["finishing"] = t -- 挂载到全局变量上，保证在程序结束前不被回收
-- 2.在程序完成垃圾回收后进行某些操作
do
    local mt = {__gc = function (o)
        print("new cycle")
        setmetatable({}, getmetatable(o))
    end}
    setmetatable({}, mt)
end
collectgarbage()
collectgarbage()
collectgarbage()
