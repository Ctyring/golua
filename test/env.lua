---
--- Generated by Luanalysis
--- Created by Lenovo.
--- DateTime: 2022/12/31 11:35
---
--for n in pairs(_G) do print(n) end -- 打印全局变量
-- 检测对全局表中不存在键的访问
--setmetatable(_G, {
--    __newindex = function(t, n, v)
--        local w = debug.getinfo(2, "S").what -- 检查赋值
--        if w ~= "main" and w ~= "C" then -- 如果赋值的主代码段或者C函数就报错(换句话说只有主代码段和C函数有权限更新)。
--            error("attempt to write to undeclared variable " .. n, 2)
--        end
--        rawset(t, n, v)
--    end,
--    __index = function(t, n)
--        error("attempt to read undeclared variable " .. n, 2)
--    end
--})
--print(a)
-- 在这种情况下我们如何声明一个新的变量？ 通过rawset绕过元表
--function declare (name, initval)
--    rawset(_G, name, initval or false) -- or false是为了避免nil值
--end
-- 检测一个变量是否存在也需要绕过元方法(否则如果为nil会得到报错)
--function isDeclared (name)
--    return rawget(_G, name) ~= nil
--end
-- _ENV
--_ENV = nil -- 通过将_ENV设置为nil来清除全局环境
--print(math.cos(13)) -- 报错
-- 显式使用_ENV
--a = 13
--local a = 12
--print(a) -- 12
--print(_ENV.a) -- 13
-- _G和_ENV的区别
-- _G是全局环境，_ENV是当前环境
--a = 15
--_ENV = {_G = _G}
--a = 1
--_G.print(_ENV.a, _G.a) -- 1 15
-- 环境和模块
-- 模块的缺点之一是很容易污染全局空间(例如忘记加local) 环境则提供了一种解决方式
--local M = {}
--_ENV = M
--function add(c1, c2)  -- 会变成M.add
--    return new(c1.r + c2.r, c1.i + c2.i) -- 会调用M.new
--end
---- 如果希望访问其他模块
--local M = {}
--
---- 导入部分
--local sqrt = math.sqrt
--local io = io
--
---- 此后不再进行外部访问
--_ENV = nil

-- 加载配置文件
env = {}
loadfile("config.lua", "t", env)() -- 将配置文件中的代码运行在空的环境env中，类似于某种沙盒，可以避免污染全局环境和恶意代码
